# Шпаргалка для криптографічного зберігання

## Вступ

У цій статті наведено просту модель, якої слід дотримуватися під час впровадження рішень для захисту даних у стані спокою.

Паролі не слід зберігати за допомогою оборотного шифрування – замість цього слід використовувати безпечні алгоритми хешування паролів. [Шпаргалка для зберігання паролів] (Password_Storage_Cheat_Sheet.md) містить додаткові вказівки щодо зберігання паролів.

## Архітектурний дизайн

Першим кроком у розробці будь-якої програми є розгляд загальної архітектури системи, оскільки це матиме величезний вплив на технічну реалізацію.

Цей процес має розпочатися з розгляду [моделі загроз] (Threat_Modeling_Cheat_Sheet.md) програми (тобто від кого ви намагаєтеся захистити ці дані).

Використання спеціалізованих систем управління секретами або ключами може забезпечити додатковий рівень захисту безпеки, а також значно спростити керування секретами, проте це коштує додаткової складності та адміністративних витрат, тому це може бути неможливим для всіх програм . Зауважте, що багато хмарних середовищ надають ці послуги, тому ними слід скористатися, де це можливо.

### Де виконувати шифрування

Шифрування може виконуватися на кількох рівнях у стеку програм, наприклад:

- На прикладному рівні.
- На рівні бази даних (наприклад, [SQL Server TDE](https://docs.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption?view=sql-server- ver15))
- На рівні файлової системи (наприклад, BitLocker або LUKS)
- На апаратному рівні (наприклад, зашифровані карти RAID або SSD)

Який(і) рівень(и) є найбільш прийнятним, залежатиме від моделі загрози. Наприклад, апаратне шифрування ефективне для захисту від фізичної крадіжки сервера, але не забезпечить захист, якщо зловмиснику вдасться скомпрометувати сервер віддалено.

### Мінімізуйте зберігання конфіденційної інформації

Найкращий спосіб захистити конфіденційну інформацію – не зберігати її. Хоча це стосується всіх типів інформації, найчастіше це стосується даних кредитних карток, оскільки вони дуже бажані для зловмисників, а PCI DSS має такі суворі вимоги до того, як вони мають зберігатися. По можливості слід уникати зберігання конфіденційної інформації.

## Алгоритми

Для симетричного шифрування **AES** із ключем принаймні **128 біт** (в ідеалі **256 біт**) і захищеним [режимом] (#cipher-modes) слід використовувати як кращий алгоритм.

Для асиметричного шифрування використовуйте криптографію за еліптичною кривою (ECC) із захищеною кривою, такою як **Curve25519** як кращий алгоритм. Якщо ECC недоступний і потрібно використовувати **RSA**, переконайтеся, що ключ має щонайменше **2048 біт**.

Доступно багато інших симетричних і асиметричних алгоритмів, які мають свої плюси і мінуси, і вони можуть бути кращими або гіршими за AES або Curve25519 у конкретних випадках використання. Розглядаючи їх, слід брати до уваги ряд факторів, зокрема:

- Розмір ключа.
- Відомі атаки та слабкі сторони алгоритму.
- Зрілість алгоритму.
- Схвалення третіми сторонами, наприклад [програмою перевірки алгоритмів NIST](https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program).
- Продуктивність (як для шифрування, так і для дешифрування).
- Якість наявних бібліотек.
- Портативність алгоритму (тобто наскільки широко він підтримується).

У деяких випадках можуть існувати нормативні вимоги, які обмежують алгоритми, які можна використовувати, як-от [FIPS 140-2](https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/ documents/fips1402annexa.pdf) або [PCI DSS](https://www.pcisecuritystandards.org/pci_security/glossary#Strong%20Cryptography).

### Спеціальні алгоритми

не роби цього

### Режими шифрування

Існують різні [режими](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation), за допомогою яких блокові шифри (наприклад, AES) можуть шифрувати довільні обсяги даних так само, як і потоковий шифр . Ці режими мають різні характеристики безпеки та продуктивності, і їх повне обговорення виходить за межі цієї шпаргалки. Деякі з режимів мають вимоги для генерації безпечних векторів ініціалізації (IV) та інших атрибутів, але бібліотека повинна обробляти їх автоматично.

Завжди слід використовувати автентифіковані режими, якщо вони доступні. Вони забезпечують гарантії цілісності та автентичності даних, а також конфіденційності. Найпоширенішими режимами автентифікації є **[GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)** і **[CCM](https://en.wikipedia.org/wiki/ CCM_mode)**, який слід використовувати як перше налаштування.

Якщо GCM або CCM недоступні, то режим [CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_%28CTR%29) або [CBC](https://en.wikipedia.org/wiki /Block_cipher_mode_of_operation#Cipher_Block_Chaining_%28CBC%29) слід використовувати режим. Оскільки вони не надають жодних гарантій автентичності даних, слід запровадити окрему автентифікацію, наприклад за допомогою [Encrypt-then-MAC](https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then- MAC_%28EtM%29). Потрібно бути обережним, використовуючи цей метод із [повідомленнями змінної довжини](https://en.wikipedia.org/wiki/CBC-MAC#Security_with_fixed_and_variable-length_messages)

[ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB) не слід використовувати поза дуже особливими обставинами.

### Випадкове доповнення

Для RSA важливо ввімкнути випадкове заповнення. Випадкове заповнення також відоме як OAEP або заповнення оптимального асиметричного шифрування. Цей клас захисту захищає від атак із відомим простим текстом, додаючи випадковість на початку корисного навантаження.

У цьому випадку зазвичай використовується схема заповнення [PKCS#1](https://wikipedia.org/wiki/RSA_(cryptosystem)#Padding_schemes).

### Безпечна генерація випадкових чисел

Випадкові числа (або рядки) потрібні для різноманітних важливих функцій безпеки, таких як генерування ключів шифрування, IV, ідентифікаторів сеансу, маркерів CSRF або маркерів скидання пароля. Таким чином, важливо, щоб вони були створені безпечно, і щоб зловмисник не міг їх вгадати та передбачити.
Зазвичай комп’ютери не можуть генерувати справді випадкові числа (без спеціального обладнання), тому більшість систем і мов забезпечують два різні типи випадковості.

Генератори псевдовипадкових чисел (PRNG) забезпечують низькоякісну випадковість, яка є набагато швидшою та може використовуватися для функцій, не пов’язаних із безпекою (наприклад, упорядкування результатів на сторінці або рандомізація елементів інтерфейсу користувача). Однак їх **не можна** використовувати для чогось критичного для безпеки, оскільки зловмисники часто можуть здогадатися або передбачити результат.

Криптографічно захищені генератори псевдовипадкових чисел (CSPRNG) створені для отримання набагато вищої якості випадковості (точніше, більшої кількості ентропії), що робить їх безпечними для використання для чутливих до безпеки функцій. Однак вони повільніші та більш інтенсивні для процесора, можуть призвести до блокування за деяких обставин, коли запитуються великі обсяги випадкових даних. Таким чином, якщо потрібна велика кількість випадковості, не пов’язаної з безпекою, вона може бути недоцільною.

У таблиці нижче наведено рекомендовані алгоритми для кожної мови, а також небезпечні функції, які не слід використовувати.

| Language | Unsafe Functions | Cryptographically Secure Functions |
|----------|------------------|------------------------------------|
| C        | `random()`, `rand()` | [getrandom(2)](http://man7.org/linux/man-pages/man2/getrandom.2.html) |
| Java     | `java.util.Random()` | [java.security.SecureRandom](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html) |
| PHP      | `rand()`, `mt_rand()`, `array_rand()`, `uniqid()` | [random_bytes()](https://www.php.net/manual/en/function.random-bytes.php), [random_int()](https://www.php.net/manual/en/function.random-int.php) in PHP 7 or [openssl_random_pseudo_bytes()](https://www.php.net/manual/en/function.openssl-random-pseudo-bytes.php) in PHP 5 |
| .NET/C#  | `Random()` | [RandomNumberGenerator](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator?view=net-6.0) |
| Objective-C | `arc4random()` (Uses RC4 Cipher) | [SecRandomCopyBytes](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes?language=objc) |
| Python   | `random()` | [secrets()](https://docs.python.org/3/library/secrets.html#module-secrets) |
| Ruby     | `Random` | [SecureRandom](https://ruby-doc.org/stdlib-2.5.1/libdoc/securerandom/rdoc/SecureRandom.html) |
| Go       | `rand` using `math/rand` package | [crypto.rand](https://golang.org/pkg/crypto/rand/) package |
| Rust     | `rand::prng::XorShiftRng` | [rand::prng::chacha::ChaChaRng](https://docs.rs/rand/0.5.0/rand/prng/chacha/struct.ChaChaRng.html) and the rest of the Rust library [CSPRNGs.](https://docs.rs/rand/0.5.0/rand/prng/index.html#cryptographically-secure-pseudo-random-number-generators-csprngs) |
| Node.js     | `Math.random()`                                   | [crypto.randomBytes](https://nodejs.org/api/crypto.html#cryptorandombytessize-callback), [crypto.randomInt](https://nodejs.org/api/crypto.html#cryptorandomintmin-max-callback), [crypto.randomUUID](https://nodejs.org/api/crypto.html#cryptorandomuuidoptions)              |   

#### UUID та GUID

Універсальні унікальні ідентифікатори (UUID або GUID) іноді використовуються як швидкий спосіб генерації випадкових рядків. Хоча вони можуть бути достатнім джерелом випадковості, це залежатиме від [типу чи версії](https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions) створеного UUID.

Зокрема, UUID версії 1 складаються з високоточної мітки часу та MAC-адреси системи, яка їх згенерувала, тому **не є випадковими** (хоча їх може бути важко вгадати, враховуючи, що мітка часу має точність до 100 нс). Ідентифікатори UUID типу 4 генеруються випадковим чином, але чи буде це зроблено за допомогою CSPRNG, залежатиме від реалізації. Не варто покладатися на випадковість UUID, якщо не відомо, що це безпечно в конкретній мові чи структурі.

### Глибокий захист

Програми повинні бути розроблені таким чином, щоб залишатися безпечними, навіть якщо криптографічний контроль не працює. Будь-яка інформація, яка зберігається в зашифрованому вигляді, також повинна бути захищена додатковими рівнями безпеки. Програма також не повинна покладатися на безпеку зашифрованих параметрів URL-адреси та має запровадити жорсткий контроль доступу, щоб запобігти несанкціонованому доступу до інформації.

## Керування ключами

### Процеси

Слід запровадити (і перевірити) офіційні процеси, щоб охопити всі аспекти управління ключами, зокрема:

- Створення та зберігання нових ключів.
- Роздача ключів необхідним особам.
- Розгортання ключів до серверів додатків.
- Заміна та виведення з експлуатації старих ключів

### Генерація ключів

Ключі мають бути згенеровані випадковим чином за допомогою криптографічно захищеної функції, як-от ті, що описані в розділі [Безпечна генерація випадкових чисел](#secure-random-number-generation). Клавіші **не повинні** базуватися на загальних словах чи фразах або на «випадкових» символах, створених за допомогою натискання клавіатури.

Якщо використовується кілька ключів (наприклад, окремі ключі для шифрування даних і ключі для шифрування даних), вони повинні бути повністю незалежними один від одного.

### Ключові терміни життя та обертання

Ключі шифрування слід змінювати (або замінювати) на основі кількох різних критеріїв:

- Якщо відомо (або підозрюється), що попередній ключ було зламано.
  - Це також може бути спричинено тим, що хтось, хто мав доступ до ключа, залишив організацію.
- Після закінчення певного періоду часу (відомого як криптоперіод).
  - Існує багато факторів, які можуть вплинути на відповідний криптоперіод, зокрема розмір ключа, чутливість даних і модель загрози системи. Додаткові вказівки див. у розділі 5.3 [NIST SP 800-57](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf).
- Після використання ключа для шифрування певної кількості даних.
  - Зазвичай це 2^35 байтів (~34 ГБ) для 64-бітних ключів і 2^68 байтів (~295 екзабайт) для 128-бітного розміру блоку.
- Якщо відбулася значна зміна безпеки, яку забезпечує алгоритм (наприклад, оголошення про нову атаку).

Після виконання одного з цих критеріїв слід створити новий ключ і використовувати його для шифрування будь-яких нових даних. Є два основні підходи до того, як слід обробляти наявні дані, зашифровані за допомогою старого ключа(ів):

1. Розшифруйте його та повторно зашифруйте за допомогою нового ключа.
2. Позначення кожного елемента ідентифікатором ключа, який використовувався для його шифрування, і збереження кількох ключів, щоб старі дані можна було розшифрувати.

Загалом слід віддати перевагу першому варіанту, оскільки він значно спрощує як код програми, так і процеси керування ключами; однак це не завжди можливо. Зауважте, що старі ключі, як правило, слід зберігати протягом певного періоду після їх вилучення, на випадок, якщо старі резервні копії копій даних потрібно буде розшифрувати.

Важливо, щоб код і процеси, необхідні для ротації ключа, були на місці **до** того, як вони будуть потрібні, щоб ключі можна було швидко замінити у випадку компрометації. Крім того, слід також запровадити процеси, які дозволяють змінювати алгоритм або бібліотеку шифрування, якщо в алгоритмі чи реалізації буде виявлено нову вразливість.

## Зберігання ключів

Безпечне зберігання криптографічних ключів є однією з найважчих проблем для вирішення, оскільки програмі завжди потрібен певний рівень доступу до ключів, щоб розшифрувати дані. Хоча неможливо повністю захистити ключі від зловмисника, який повністю скомпрометував програму, можна зробити ряд кроків, щоб ускладнити для нього отримання ключів.

Там, де це можливо, слід використовувати безпечні механізми зберігання, надані операційною системою, фреймворком або постачальником хмарних послуг. До них належать:

- Фізичний апаратний модуль безпеки (HSM).
- Віртуальний HSM.
- Сховища ключів, як-от [Amazon KMS](https://aws.amazon.com/kms/) або [Azure Key Vault](https://azure.microsoft.com/en-gb/services/key-vault/ ).
- API безпечного зберігання, надані класом [ProtectedData](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.protecteddata?redirectedfrom=MSDN&view=netframework-4.8) у .NET рамка.

Використання цих типів безпечного зберігання має багато переваг перед простим розміщенням ключів у файлах конфігурації. Специфіка їх буде відрізнятися залежно від використовуваного рішення, але вони включають:

- Централізоване керування ключами, особливо в контейнерних середовищах.
- Легкий поворот і заміна ключів.
- Безпечна генерація ключів.
- Спрощення дотримання нормативних стандартів, таких як FIPS 140 або PCI DSS.
- Ускладнення для зловмисника експорту або викрадення ключів.

У деяких випадках жодне з них не буде доступним, наприклад, у спільному хостинговому середовищі, що означає, що неможливо отримати високий ступінь захисту для будь-яких ключів шифрування. Однак наступних основних правил все ж можна дотримуватися:

- Не закодуйте ключі у вихідний код програми.
- Не перевіряйте ключі в системах контролю версій.
- Захист конфігураційних файлів, що містять ключі, з обмеженими дозволами.
- Уникайте зберігання ключів у змінних середовища, оскільки їх можна випадково розкрити через такі функції, як [phpinfo()](https://www.php.net/manual/en/function.phpinfo.php) або через `/proc файл /self/environ`.

### Розділення ключів і даних

Якщо можливо, ключі шифрування слід зберігати окремо від зашифрованих даних. Наприклад, якщо дані зберігаються в базі даних, ключі повинні зберігатися у файловій системі. Це означає, що якщо зловмисник має доступ лише до одного з них (наприклад, через обхід каталогу або впровадження SQL), він не може отримати доступ і до ключів, і до даних.

Залежно від архітектури середовища може бути можливим зберігати ключі та дані в окремих системах, що забезпечить більший ступінь ізоляції.

### Шифрування збережених ключів

Там, де можливо, самі ключі шифрування повинні зберігатися в зашифрованому вигляді. Для цього потрібні принаймні два окремі ключі:

- Для шифрування даних використовується ключ шифрування даних (DEK).
- Ключ шифрування ключа (KEK) використовується для шифрування DEK.

Щоб це було ефективним, KEK потрібно зберігати окремо від DEK. Зашифрований DEK можна зберігати разом із даними, але його можна буде використовувати, лише якщо зловмисник зможе також отримати KEK, який зберігається в іншій системі.

KEK також має бути принаймні таким же міцним, як DEK. Посібник із [шифрування конверта](https://cloud.google.com/kms/docs/envelope-encryption) від Google містить додаткові відомості про те, як керувати DEK і KEK.

У простіших архітектурах додатків (таких як середовища спільного хостингу), де KEK і DEK не можна зберігати окремо, цей підхід має обмежену цінність, оскільки зловмисник, ймовірно, зможе отримати обидва ключі одночасно. Однак це може стати додатковим бар’єром для некваліфікованих зловмисників.

Функцію виведення ключа (KDF) можна використовувати для генерації KEK із введених користувачем даних (наприклад, парольної фрази), який потім використовуватиметься для шифрування випадково згенерованого DEK. Це дозволяє легко змінювати KEK (коли користувач змінює свою парольну фразу) без необхідності повторного шифрування даних (оскільки DEK залишається незмінним).

# Шпаргалка з управління ключами

## Вступ

Ця шпаргалка з керування ключами надає розробникам інструкції щодо впровадження безпечного керування криптографічним ключем у програмі. Важливо задокументувати та узгодити правила та практику для:

1. управління життєвим циклом ключів (генерація, розподіл, знищення)
2. компроміс ключа, відновлення та обнулення
3. зберігання ключів
4. ключова угода

## Загальні вказівки та міркування

Сформулюйте план загальної криптографічної стратегії організації, щоб спрямовувати розробників, які працюють над різними програмами, і забезпечити відповідність криптографічних можливостей кожної програми мінімальним вимогам і найкращим практикам.

Визначте криптографічні вимоги та вимоги до керування ключами для вашої програми та зіставте всі компоненти, які обробляють або зберігають матеріал криптографічного ключа.

## Вибір ключа

Вибір криптографічних алгоритмів і алгоритмів керування ключами для використання в певній програмі слід починати з розуміння цілей програми.

Наприклад, якщо програмі потрібно безпечно зберігати дані, розробник повинен вибрати набір алгоритмів, який підтримує мету захисту даних у стані спокою. Програми, яким потрібно передавати й отримувати дані, вибиратимуть набір алгоритмів, який підтримує ціль захисту даних під час передавання.

Ми надали рекомендації щодо вибору криптопакетів у програмі на основі цілей програми та безпеки. Розробники додатків часто починають розробку криптографії та можливостей керування ключами з вивчення того, що доступно в бібліотеці.

Однак слід провести аналіз реальних потреб програми, щоб визначити оптимальний підхід до керування ключами. Почніть із розуміння цілей безпеки програми, які потім керуватимуть вибором найкраще підходящих криптографічних протоколів. Наприклад, додаток може вимагати:

1. Конфіденційність даних у стані спокою та конфіденційність даних у дорозі.
2. Автентичність кінцевого пристрою.
3. Автентичність походження даних.
4. Цілісність даних під час передачі.
5. Ключі для створення ключів шифрування даних.

Після досягнення розуміння потреб безпеки програми розробники можуть визначити, які протоколи та алгоритми потрібні. Після того, як протоколи та алгоритми зрозуміли, ви можете почати визначати різні типи ключів, які підтримуватимуть цілі програми.

Існує різноманітний набір типів ключів і сертифікатів, які слід враховувати, наприклад:

1. **Шифрування:** [симетричні](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) ключі шифрування, [асиметричні](https://en.wikipedia.org/wiki/Public-key_cryptography ) ключі шифрування (відкриті та закриті).
2. **Автентифікація кінцевих пристроїв:** Попередньо спільні симетричні ключі, довірені сертифікати, довірчі прив’язки.
3. **Автентифікація джерела даних:** [HMAC](https://en.wikipedia.org/wiki/HMAC).
4. **Захист цілісності:** [Коди автентифікації повідомлень](https://en.wikipedia.org/wiki/Message_authentication_code) (MAC).
5. **Ключі шифрування ключів**.

### Алгоритми та протоколи

Відповідно до `NIST SP 800-57 Part 1`, багато алгоритмів і схем, які забезпечують службу безпеки, використовують [хеш-функцію](https://en.wikipedia.org/wiki/Hash_function) як компонент алгоритму.

Хеш-функції можна знайти в алгоритмах цифрового підпису (FIPS186), хешованих кодах автентифікації повідомлень (HMAC) (FIPS198), функціях/методах отримання ключів (NIST Special Publications (SP) 800-56A, 800- 56B, 800-56C і 800-108`) і генератори випадкових чисел (`NIST SP 800-90A`). Схвалені хеш-функції визначено в `FIPS180`.

`NIST SP 800-57 Частина 1` визнає три основні класи затверджених криптографічних алгоритмів: хеш-функції, алгоритми з симетричним ключем і алгоритми з асиметричним ключем. Класи визначаються кількістю криптографічних ключів, які використовуються в поєднанні з алгоритмом.

АНБ опублікувало звіт [Commercial National Security Algorithm Suite 2.0](https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF), у якому перелічено криптографічні алгоритми, які, як очікується, залишаться сильними навіть завдяки прогресу квантових обчислень.

#### Криптографічні хеш-функції
Криптографічні хеш-функції не потребують ключів. Хеш-функції генерують відносно невеликий дайджест (геш-значення) із (можливо) великого вхідного сигналу таким чином, що принципово важко повернути назад (тобто важко знайти вхідні дані, які дадуть заданий вихід). Хеш-функції використовуються як будівельні блоки для керування ключами, наприклад,

1. Для надання послуг автентифікації та цілісності даних (розділ 4.2.3) – хеш-функція використовується з ключем для генерації коду автентифікації повідомлення.
2. Стискати повідомлення для створення та перевірки цифрового підпису (п. 4.2.4).
3. Отримувати ключі в алгоритмах встановлення ключів (розділ 4.2.5).
4. Генерувати детерміновані випадкові числа (розділ 4.2.7).

#### Алгоритми з симетричним ключем

Алгоритми симетричного ключа (іноді відомі як алгоритми секретного ключа) перетворюють дані таким чином, що принципово важко скасувати без знання секретного ключа. Ключ є «симетричним», тому що той самий ключ використовується для криптографічної операції та її зворотної дії (наприклад, шифрування та дешифрування).

Симетричні ключі часто відомі більш ніж одній сутності; однак ключ не розголошується особам, які не мають авторизованого доступу до даних, захищених цим алгоритмом і ключем. Симетричні ключові алгоритми використовуються, наприклад,

1. Забезпечити конфіденційність даних (п. 4.2.2); один і той же ключ використовується для шифрування і дешифрування даних.
2. Надавати послуги автентифікації та цілісності (розділ 4.2.3) у формі кодів автентифікації повідомлень (MAC); той самий ключ використовується для генерації MAC та його перевірки. MAC зазвичай використовують або симетричний алгоритм шифрування з ключем, або криптографічну хеш-функцію як свій криптографічний примітив.
3. Як частина процесу встановлення ключа (розділ 4.2.5).
4. Генерувати детерміновані випадкові числа (розділ 4.2.7).

#### Алгоритми з асиметричним ключем

Алгоритми з асиметричним ключем, широко відомі як алгоритми з відкритим ключем, використовують два пов’язані ключі (тобто пару ключів) для виконання своїх функцій: відкритий ключ і закритий ключ. Відкритий ключ може бути відомий кожному; особистий ключ має бути під одноосібним контролем суб’єкта, який «володіє» парою ключів. Незважаючи на те, що відкритий і закритий ключі пари ключів пов’язані, знання відкритого ключа не розкриває закритий ключ. Асиметричні алгоритми використовуються, наприклад,

1. Для обчислення цифрових підписів (розділ 4.2.4).
2. Створити матеріал криптографічного ключа (розділ 4.2.5).
3. Генерувати випадкові числа (розділ 4.2.7).

#### Коди автентифікації повідомлень (MAC)

Коди автентифікації повідомлень (MAC) забезпечують автентифікацію та цілісність даних. MAC — це криптографічна контрольна сума даних, яка використовується для забезпечення впевненості в тому, що дані не змінилися та що MAC був обчислений очікуваною сутністю.

Хоча цілісність повідомлення часто забезпечується за допомогою некриптографічних методів, відомих як коди виявлення помилок, ці коди можуть бути змінені зловмисником, щоб здійснити дію на користь зловмисника. Використання схваленого криптографічного механізму, такого як MAC, може полегшити цю проблему.

Крім того, MAC може забезпечити одержувача впевненістю, що автор даних є власником ключа (тобто суб’єктом, уповноваженим мати ключ). MAC-адреси часто використовуються для автентифікації відправника перед одержувачем, коли лише ці дві сторони мають спільний MAC-ключ.

#### Цифрові підписи

[Цифрові підписи](https://en.wikipedia.org/wiki/Digital_signature) використовуються для забезпечення автентифікації, цілісності та [невідмовності](https://en.wikipedia.org/wiki/Non-repudiation). Цифрові підписи використовуються в поєднанні з хеш-функціями та обчислюються на даних будь-якої довжини (до обмеження, яке визначається хеш-функцією).

`FIPS186` визначає алгоритми, схвалені для обчислення цифрових підписів.

#### Ключі шифрування ключів

Симетричні ключі упаковки ключів використовуються для шифрування інших ключів за допомогою алгоритмів симетричного ключа. Ключі упаковки ключів також відомі як ключі шифрування ключів.

### Ключова сила

Перегляньте `NIST SP 800-57` (Рекомендації щодо керування ключами), щоб отримати рекомендовані вказівки щодо міцності ключа для конкретних реалізацій алгоритму. Також зверніть увагу на ці найкращі практики:

1. Встановіть мінімальну обчислювальну стійкість програми до атак. Розуміння мінімальної обчислювальної стійкості до атак має брати до уваги досвід ваших опонентів, як довго дані потрібно захищати, де дані зберігаються та чи вони піддаються. Визначення обчислювальної стійкості до атак дасть інженерам інформацію про мінімальну довжину криптографічного ключа, необхідного для захисту даних протягом усього терміну служби цих даних. Зверніться до `NIST SP 800-131a`, щоб отримати додаткові вказівки щодо визначення відповідної довжини ключа для вибраного алгоритму.
2. Під час шифрування ключів для зберігання або розповсюдження завжди шифруйте криптографічний ключ за допомогою іншого ключа з рівною чи більшою криптографічною міцністю.
3. Переходячи до [алгоритмів на основі еліптичної кривої](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), виберіть довжину ключа, яка відповідає або перевищує порівняльну силу інших алгоритмів, що використовуються у вашій системі. Див. `NIST SP 800-57 Таблиця 2`.
4. Сформулюйте стратегію для загальної криптографічної стратегії організації, щоб керувати розробниками, які працюють над різними програмами, і гарантувати, що криптографічні можливості кожної програми відповідають мінімальним вимогам і найкращим практикам.

### Зауваження щодо керування пам'яттю

Ключі, які довго зберігалися в пам'яті, можуть "згоріти". Це можна пом’якшити, розділивши ключ на компоненти, які часто оновлюються. `NIST SP 800.57`).

Втрата або пошкодження носія пам’яті, на якому зберігаються ключі та/або сертифікати, і планування відновлення відповідно до `NIST SP 800.57`.

Сплануйте відновлення від можливого пошкодження носія пам’яті, необхідного для генерації ключів або сертифікатів, реєстрації та/або систем розповсюдження, підсистем або компонентів, як рекомендовано в «NIST SP 800.57».

### Ідеальна секретність

[Ефемерні ключі](https://en.wikipedia.org/wiki/Ephemeral_key) можуть забезпечити ідеальний захист конфіденційності, тобто компрометація довгострокового ключа підпису сервера не порушує конфіденційності минулих сеансів. Див. [шпаргалку TLS] (Transport_Layer_Protection_Cheat_Sheet.md).

### Використання ключа

Відповідно до NIST, загалом один ключ слід використовувати лише для однієї мети (наприклад, шифрування, автентифікації, упаковки ключів, генерації випадкових чисел або цифрових підписів).

На це є кілька причин:

1. Використання одного ключа для двох різних криптографічних процесів може послабити безпеку, яку забезпечує один або обидва процеси.
2. Обмеження використання ключа обмежує шкоду, яка може бути завдана, якщо ключ скомпрометовано.
3. Деякі способи використання ключів заважають один одному. Наприклад, тривалість часу, протягом якого ключ може знадобитися для кожного використання та цілі. Вимоги до зберігання даних можуть відрізнятися для різних типів даних.

### Теми криптографічного модуля

Згідно з `NIST SP800-133`, криптографічні модулі — це набір апаратного, програмного та/або вбудованого програмного забезпечення, яке реалізує функції безпеки (включаючи криптографічні алгоритми та генерацію ключів) і міститься в межах криптографічного модуля для забезпечення захисту ключів.

## Кращі практики життєвого циклу керування ключами

### Покоління

Криптографічні ключі повинні бути згенеровані в криптографічному модулі, щонайменше має відповідність `FIPS 140-2`. Для пояснення розглянемо криптографічний модуль, у якому генерується ключ, як модуль генерації ключа.

Будь-яке випадкове значення, необхідне модулю генерації ключів, має бути згенеровано в цьому модулі; тобто Генератор випадкових бітів, який генерує випадкове значення, має бути реалізований у криптографічному модулі з принаймні відповідністю `FIPS 140-2`, який генерує ключ.

Для захисту апаратні криптографічні модулі є кращими перед програмними криптографічними модулями.

### Розподіл

Згенеровані ключі повинні транспортуватися (за необхідності) за допомогою захищених каналів і використовуватися пов’язаним із ними криптографічним алгоритмом принаймні в криптографічних модулях, сумісних із `FIPS 140-2`. Щоб отримати додаткові відомості щодо рекомендацій у цьому розділі, зверніться до `NIST Special Paper 800-133`.

### Зберігання

1. Розробники повинні розуміти, де в програмі зберігаються криптографічні ключі. Зрозумійте, на яких пристроях пам’яті зберігаються ключі.
2. Ключі повинні бути захищені як в енергозалежній, так і в постійній пам’яті, в ідеалі оброблятися в захищених криптографічних модулях.
3. Ключі ніколи не повинні зберігатися у форматі відкритого тексту.
4. Переконайтеся, що всі ключі зберігаються в криптографічному сховищі, наприклад [апаратному модулі безпеки](https://en.wikipedia.org/wiki/Hardware_security_module) (HSM) або ізольованій криптографічній службі.
5. Якщо ви плануєте зберігати ключі в автономних пристроях/базах даних, зашифруйте ключі за допомогою ключів шифрування ключів (KEK) перед експортом матеріалу ключа. Довжина KEK (і алгоритм) має бути еквівалентною або більшою за потужністю, ніж захищені ключі.
6. Переконайтеся, що ключі мають захист цілісності під час зберігання (розгляньте алгоритми подвійного призначення, які підтримують шифрування та автентифікацію коду повідомлення (MAC)).
7. Переконайтеся, що стандартний код рівня програми ніколи не зчитує та не використовує криптографічні ключі будь-яким способом, і використовуйте бібліотеки керування ключами.
8. Переконайтеся, що ключі та криптографічна операція виконуються всередині запечатаного сховища.
9. Усю роботу слід виконувати в сховищі (наприклад, доступ до ключа, шифрування, дешифрування, підписання тощо).

### Депонування та резервне копіювання

Дані, зашифровані за допомогою втрачених криптографічних ключів, ніколи не будуть відновлені. Тому дуже важливо, щоб програма включала можливість безпечного резервного копіювання ключів, особливо для програм, які підтримують шифрування даних у стані спокою для довгострокових сховищ даних.

Під час резервного копіювання ключів переконайтеся, що база даних, яка використовується для зберігання ключів, зашифрована принаймні за допомогою перевіреного модуля `FIPS 140-2`. Іноді корисно депонувати ключовий матеріал для використання в розслідуваннях і для повторного надання ключового матеріалу користувачам у випадку, якщо ключ втрачено або пошкоджено.

Ніколи не використовуйте ключі депонування для виконання цифрових підписів, але враховуйте необхідність ключів депонування, які підтримують шифрування. Часто депонування може виконувати [Центр сертифікації](https://en.wikipedia.org/wiki/Certificate_authority) (CA) або система керування ключами, яка надає сертифікати та ключі, однак у деяких випадках потрібно впроваджувати окремі API, дозволити системі виконати депонування для програми.

### Підзвітність і аудит

Підзвітність передбачає ідентифікацію тих, хто має доступ до криптографічних ключів або контролює їх протягом усього їх життєвого циклу. Підзвітність може бути ефективним інструментом, який допоможе запобігти ключовим компрометаціям і зменшити вплив компрометацій після їх виявлення.

Хоча бажано, щоб ніхто з людей не міг переглядати ключі, як мінімум система керування ключами повинна враховувати всіх осіб, які можуть переглядати криптографічні ключі відкритого тексту.

Крім того, більш складні системи керування ключами можуть враховувати всіх осіб, уповноважених на доступ або контроль будь-яких криптографічних ключів, у формі відкритого або зашифрованого тексту.

Підзвітність дає три важливі переваги:

1. Це допомагає визначити, коли міг відбутися компроміс і які особи могли бути залучені.
2. Він прагне захистити від компрометації, оскільки особи, які мають доступ до ключа, знають, що їхній доступ до ключа відомий.
3. Для відновлення після виявленого зламаного ключа дуже корисно знати, де використовувався ключ і які дані чи інші ключі були захищені зламаним ключем.

Певні принципи виявилися корисними для забезпечення підзвітності криптографічних ключів. Ці принципи можуть не застосовуватися до всіх систем або всіх типів ключів.

Деякі з принципів, які застосовуються до довгострокових ключів, керованих людьми, включають:

1. Унікальна ідентифікація ключів.
2. Ідентифікація ключового користувача.
3. Визначення дат і часу використання ключа, а також даних, які захищаються.
4. Ідентифікація інших ключів, які захищені симетричним або закритим ключем.

Для ключових систем управління слід проводити два типи аудиту:

1. План безпеки та процедури, розроблені для підтримки плану, повинні періодично перевірятися, щоб переконатися, що вони продовжують підтримувати Політику керування ключами ("NIST SP 800-57 Частина 2").
2. Застосовувані захисні механізми слід періодично переглядати щодо рівня безпеки, який вони забезпечують і, як очікується, забезпечуватимуть у майбутньому, а також того, що механізми правильно та ефективно підтримують відповідну політику.

Необхідно враховувати нові технології та атаки. Слід частіше переглядати дії людей, які використовують, керують і обслуговують систему, щоб переконатися, що люди продовжують дотримуватися встановлених процедур безпеки.

Сильні криптографічні системи можуть бути скомпрометовані недбалими та неналежними діями людини. Дуже незвичні події слід відзначати та розглядати як можливі індикатори спроб атак на систему.

### Злам і відновлення ключа

Злама ключа має такі наслідки:

1. Загалом, несанкціоноване розкриття ключа, який використовується для забезпечення захисту конфіденційності (тобто за допомогою шифрування), означає, що вся інформація, зашифрована цим ключем, може бути розкрита або відома неавторизованим особам. Розкриття приватного ключа підпису центру сертифікатів означає, що зловмисник може створювати фальшиві сертифікати та списки відкликаних сертифікатів (CRL).
2. Порушення цілісності ключа означає, що ключ неправильний - або те, що ключ було змінено (чи навмисно, чи випадково), або що інший ключ був замінений; це включає видалення (недоступність) ключа. Заміна або модифікація ключа, який використовується для забезпечення цілісності, ставить під сумнів цілісність усієї інформації, захищеної ключем. Ця інформація могла бути надана або змінена неавторизованою організацією, яка знає ключ. Заміна відкритого або секретного ключа, який використовуватиметься (пізніше) для шифрування даних, може дозволити неавторизованій організації (яка знає ключ розшифровки) розшифрувати дані, зашифровані за допомогою ключа шифрування.
3. Порушення використання ключа або асоціації програми означає, що ключ може використовуватися з неправильною метою (наприклад, для встановлення ключа замість цифрових підписів) або для неправильної програми, і може призвести до компрометації інформації, захищеної ключ.
4. Порушення асоціації ключа з власником або іншою сутністю означає, що ідентичність іншої сутності не може бути гарантована (тобто невідомо, ким насправді є інша сутність) або що інформація не може бути оброблена правильно (наприклад, розшифрована з правильним ключем).
5. Компроміс асоціації ключа з іншою інформацією означає, що асоціації немає взагалі, або асоціація пов’язана з неправильною «інформацією». Це може призвести до збою криптографічних служб, втрати інформації або порушення безпеки інформації. Певні захисні заходи можуть бути вжиті, щоб мінімізувати ймовірність або наслідки ключового компромісу. Вплив подібний до програм-вимагачів, за винятком того, що ви не можете заплатити викуп і отримати ключ назад.

Зазвичай застосовуються такі процедури:

1. Обмеження часу, протягом якого симетричний або закритий ключ знаходиться у формі відкритого тексту.
2. Запобігання перегляду відкритим текстом симетричних і закритих ключів.
3. Обмеження відкритих симетричних і закритих ключів фізично захищеними контейнерами. Це включає генератори ключів, пристрої транспортування ключів, завантажувачі ключів, криптографічні модулі та пристрої зберігання ключів.
4. Використання перевірки цілісності, щоб переконатися, що цілісність ключа або його зв’язок з іншими даними не порушено. Наприклад, ключі можуть бути упаковані (тобто зашифровані) таким чином, що будуть виявлені неавторизовані модифікації упаковки або асоціацій.
5. Використання підтвердження ключа (див. NIST SP 800-57, частина 1, розділ 4.2.5.5), щоб переконатися, що правильний ключ дійсно встановлено.
6. Створення системи звітності, яка відстежує кожен доступ до симетричних і закритих ключів у формі відкритого тексту.
7. Забезпечення криптографічної перевірки цілісності ключа (наприклад, за допомогою MAC або цифрового підпису).
8. Використання довірених позначок часу для підписаних даних. i. Знищення ключів, як тільки вони більше не потрібні.
9. Створення плану компромісу-відновлення, особливо у випадку компромісу CA.

План відновлення компромісу необхідний для відновлення служб криптографічної безпеки у разі компрометації ключа. План відновлення компромісу повинен бути задокументований і легко доступний.

План відновлення компромісу повинен містити:

1. Ідентифікаційна та контактна інформація персоналу, якого потрібно повідомити.
2. Ідентифікація та контактна інформація персоналу для виконання дій з відновлення.
3. Метод повторного ключа.
4. Перелік усіх криптографічних ключів та їх використання (наприклад, розташування всіх сертифікатів у системі).
5. Навчання всього відповідного персоналу процедурам відновлення.
6. Ідентифікація та контактна інформація всього персоналу, необхідного для підтримки процедур відновлення.
7. Політики, що перевіряють відкликання ключа (для мінімізації ефекту компромісу).
8. Моніторинг операцій зміни ключів (щоб переконатися, що всі необхідні операції виконуються для всіх зачеплених ключів).
9. Будь-які інші процедури відновлення, які можуть включати:
  1. Фізичний огляд обладнання.
  2. Ідентифікація всієї інформації, яка може бути скомпрометована в результаті інциденту.
  3. Ідентифікація всіх підписів, які можуть бути недійсними через компрометацію ключа підпису.
  4. Розповсюдження нового матеріалу для ключів, якщо потрібно.

## Довірені магазини

1. Розробка елементів керування для захисту надійного сховища від ін’єкції сторонніх кореневих сертифікатів. Керування доступом здійснюється на основі сутності та програми.
2. Реалізуйте контроль цілісності об’єктів, що зберігаються в надійному сховищі.
3. Не дозволяйте експортувати ключі, які зберігаються в довіреному сховищі, без автентифікації та авторизації.
4. Налаштуйте суворі політики та процедури для експорту ключових матеріалів із додатків до мережевих додатків та інших компонентів.
5. Запровадити безпечний процес для оновлення надійного сховища.

## Бібліотеки керування криптографічними ключами

Використовуйте лише надійні криптобібліотеки, які належним чином обслуговуються та оновлюються, а також перевірені та перевірені сторонніми організаціями (наприклад, `NIST`/`FIPS`).

## Документація

- [Повний посібник із основ керування ключами шифрування](https://info.townsendsecurity.com/definitive-guide-to-encryption-key-management-fundamentals).
- [Практична криптографія для розробників](https://cryptobook.nakov.com/).

